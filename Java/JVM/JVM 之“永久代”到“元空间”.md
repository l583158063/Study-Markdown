JVM 之“永久代”到“元空间”
---
#### 一、JVM 内存模型
![image](https://upload-images.jianshu.io/upload_images/16969231-c55be62af6d1d537.png?imageMogr2/auto-orient/strip|imageView2/2/w/578)
![image](https://upload-images.jianshu.io/upload_images/16969231-4058bcb06cc8e24f.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)

##### 1、虚拟机栈：

- JVM栈是**线程私有**的内存区域。它描述的是 Java 方法执行的内存模型，每个方法执行的同时都会创建一个栈帧（Stack Frame）用于存储**局部变量表、操作数栈、动态链接、方法出口**等信息。每个方法从调用直至完成的过程，都对应着一个栈帧从入栈到出栈的过程。每当一个方法执行完成时，该栈帧就会弹出栈帧的元素作为这个方法的返回值，并且清除这个栈帧，Java栈的栈顶的栈帧就是当前正在执行的活动栈，也就是当前正在执行的方法。就像是组成动画的一帧一帧的图片，方法的调用过程也是由栈帧切换来产生结果。

- 局部变量表存放了编译器可知的各种**基本数据类型**（int、short、byte、char、double、float、long、boolean）、**对象引用**（reference 类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和**returnAddress 类型**（指向了一跳字节码指令的地址）。 一个对象只对应了一个4byte的引用（堆栈分离的好处），存储的元素长度比较固定。 

- 在JVM规范中，对这个区域规定了两种异常情况：

  - 如果线程请求的栈深度大于虚拟机允许的深度，将抛出 **StackOverflowError** 异常；

  - 如果虚拟机栈可以动态扩展，在扩展时无法申请到足够的内存，就会抛出 **OutOfMemoryError **异常。

> 这里有一个小细节需要注意，catch 捕获的是 **Throwable**，而不是 Exception。因为 StackOverflowError 和 OutOfMemoryError 都不属于 Exception 的子类。

##### 2、本地方法栈：

- 本地方法栈和虚拟机栈所发挥的作用是很相似的，它们之间的区别不过是 虚拟机栈为虚拟机执行 Java 方法（字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。Java 程序员一般不需要关注这块区域。Sun HotSpot 直接就把本地方法栈和虚拟机栈合二为一。本地方法栈也会抛出 StackOverflowError 和 OutOfMemoryError 异常。

##### 3、PC 寄存器（程序计数器）：
- JVM 支持多个线程同时运行，每个线程都有自己的程序计数器。倘若当前执行的是 JVM 的方法，则该寄存器中保存当前执行指令的地址；倘若执行的是 native 方法，则PC寄存器中为空。这是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机概念模型里（概念模型，各种虚拟机可能会通过一些更高效的方式实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令：分支、跳转、循环、异常处理、线程恢复等基础操作都会依赖这个计数器来完成。每个线程都有独立的程序计数器，用来在线程切换后能恢复到正确的执行位置，各条线程之间的计数器互不影响，独立存储。所以它是一个“线程私有”的内存区域。此内存区域是唯一一个在 JVM 规范中没有规定任何 OutOfMemoryError 情况的区域。

##### 4、堆：

- 对于大多数 Java 应用来说，堆（Heap）是 JVM 所管理的内存中最大的一块，是 JVM **所有线程共享**的部分，在虚拟机启动的时候就已经创建。Heap 是 OOM 故障最主要的发源地，所有的**对象（Object）和数组（Array）**都在堆上进行分配。堆由垃圾收集器自动回收，是垃圾收集器管理的主要区域，也被称为“GC堆”。从内存回收的角度来看，堆可以细分为：新生代和老年代；再细致一点可分为：Eden 空间、From Survivor 空间、To Survivor 空间（空间分配比例是8：1：1）。通常情况下，它占用的空间是所有内存区域中最大的，但如果无节制地创建大量对象，也容易消耗完所有的空间。当申请不到空间时会抛出 OutOfMemoryError。

##### 5、方法区：

- 方法区也是所有线程共享。主要用于存储**类的信息、常量池、类方法数据和代码**等。方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”。 关于方法区内存溢出的问题会在下文中详细探讨。
> **静态常量池**： 即*.class文件中的常量池，class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间。 主要用于存放两大类常量： 
>
> - 字面量：Java语言层面常量的概念，如：文本字符串，声明为 final 的常量值等。
> - 符号引用：属于编译原理方面的概念，如：类和接口的全限定名、字段名称和描述符、方法名称和描述符。
> 
>**运行时常量池**：在Java程序中，有很多的东西是永恒的，不会在运行过程中变化，比如**类和类的元数据信息**（一个**类的名字**，一个类**字段的名字/所属类型**，一个类**方法的名字/返回类型/参数名与所属类型**）和在程序中出现的大量的**字面量**等。而这些在 JVM 解释执行程序的时候是非常重要的。 JVM 在完成类装载操作以及编译器将源程序**编译成 class 文件后**，会用一部分字节分类存储这些不变的字节码，将 class 文件中的这些信息载入到内存，并保存在方法区中。**我们常说的常量池，就是指方法区中的运行时常量池**。 

#### 二、 **内存申请过程**

1. JVM 会试图为相关 Java 对象在年轻代的 Eden 区中初始化一块内存区域。

2. 当 Eden 区空间足够时，内存申请结束。否则执行下一步。

3. JVM 试图释放在 Eden 区中所有不活跃的对象（Minor GC）。释放后若 Eden 空间仍然不足以放入新对象，JVM 则试图将部分 Eden 区中活跃对象放入 Survivor 区。

4. Survivor 区被用来作为 Eden 区及年老代Old区的中间交换区域。当年老代空间足够时，Survivor 区中存活了一定次数的对象会被移到年老代。

5. 当年老代空间不够时，JVM会在年老代进行完全的垃圾回收（Major GC）。

6. Major GC 后，若 Survivor 区及年老代仍然无法存放从 Eden 区复制过来的对象，则会导致 JVM 无法在 Eden 区为新生成的对象申请内存，即出现“Out of Memory: Java Heap Space”。

> 老年代存储长期存活的对象，占满时会触发 Major GC = Full GC，GC 期间会停止所有线程等待 GC 完成，所以对响应要求高的应用尽量减少发生 Major GC，避免响应超时。
>
> Minor GC ： 清理年轻代 
> Major GC ： 清理老年代
> Full GC ： 清理整个堆空间，包括年轻代和永久代
> 所有 GC 都会停止应用所有线程。 

#### 三、PermGen 永久代

##### 1、永久代概述

​        永久代（Permanent Generation space）指的就是**方法区**（这个概念是 Jdk Version < 1.8 才有的）。不过方法区和“PermGen space”又有着本质的区别。前者是 JVM 的规范，而后者则是 JVM 规范的一种实现，并且只有 HotSpot（Oracle-Sun） 才有 “PermGen space”，而对于其他类型的虚拟机，如 JRockit（Oracle）、J9（IBM）、Taobao VM 并没有“PermGen space”。

​        永久代对垃圾回收没有显著影响，其中包含了虚拟机中所有可通过**反射**获取到的数据，比如 **Class 和 Meta 的信息**，Class 在被 Load 的时候被放入 PermGen space 区域，它和存放 Instance 的堆区域不同，所以对于动态生成类的情况（如加载很多 Class）比较容易出现永久代的内存溢出，就很可能出现 PermGen space 错误。
> **Class和Meta包含：**
>
> - JVM 中类的元数据（Meta）在 Java 堆中的存储区域。
> - Java 类对应的 HotSpot 虚拟机中的内部表示也存储在这里。
> - 类（Class）的层级信息，字段，名字。
> - 方法的编译信息及字节码。
> - 变量
> - 常量池和符号解析

​        这种错误常见在web服务器对 JSP 进行 pre compile 的时候。或者是用工具动态生成或调用大量 Class 时，如 Hibernate CGLib 等。

​        不同的 Java 虚拟机之间可能会进行类共享，因此永久代又分为只读区和读写区。JVM 用于描述应用程序中用到的类和方法的元数据也存储在永久代中。JVM 运行时会用到多少永久代的空间取决于应用程序用到了多少类。除此之外，Java SE 库中的类和方法也都存储在这里。

#####  2、永久代的大小

- 它的上限是 MaxPermSize，默认是 64M。
- Java 堆中的连续区域：如果存储在非连续的堆空间中的话，要定位出持久代到新对象的引用非常复杂并且耗时。卡表（card table），是一种记忆集（Remembered Set），它用来记录某个内存代中普通对象指针（oops）的修改。
- 需要多大的持久代空间取决于类的数量，方法的大小，以及常量池的大小。

##### 3、※※※ `移除永久代后，数据存储位置的变化` ※※※

​        移除永久代的工作从 JDK 1.7 就开始了。JDK 1.7 中，存储在永久代的部分数据就已经转移到了 Java Heap 或者是 Native Heap。但永久代仍存在于 JDK 1.7 中，并没完全移除，经过对方法区的分裂后已经几乎只存储**类和类的元数据信息** 。而**符号引用（Symbolic References）转移到了native heap**；**字面量（Literal）和类的静态变量（Class statics）转移到了 Java Heap**。JDK 1.8 以后**方法区移至 Metaspace**，即包含**类**和**类的元数据信息（含类加载器、方法信息和编译后的代码等）**的**运行时常量池**存入了元空间。

```java
/**
 * 测试 Java 8 中静态变量移入堆区
 * 静态字符串变量按指数为二倍增长，并用列表对象保存其引用，保证不被回收
 * 运行不久内存会溢出，抛出 OutOfMemoryError : Java heap space
 */
public class StringOomTest {
    static String base = "string";
    public static void main(final String[] args) {
        final List<String> list = new ArrayList<>();
        for (int i = 0; i < Integer.MAX_VALUE; i++) {
            final String str = base + base;
            base = str;
            list.add(str.intern());
        }
    }
}
```

#### 四、Metaspace 元空间

##### 1、元空间概述

​        元空间的本质和永久代类似，都是对 JVM 规范中**方法区的实现**。不过元空间与永久代之间最大的区别在于：**元空间并不在虚拟机中，而是使用本地内存**。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：
- -XX:MetaspaceSize：初始空间大小，如果没有指定的话，元空间会根据应用程序运行时的需要动态地调整大小。 ，达到该值就会触发垃圾收集进行类型卸载，同时 GC 会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过 MaxMetaspaceSize 时，适当提高该值。
- -XX:MaxMetaspaceSize：最大空间，默认是没有限制的，内存有多大就是多大。
**除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：**
- -XX:MinMetaspaceFreeRatio：在GC之后，最小的 Metaspace 剩余（空闲）空间容量的百分比，减少为分配空间所导致的垃圾收集。
- -XX:MaxMetaspaceFreeRatio：在GC之后，最大的 Metaspace 剩余（空闲）空间容量的百分比，减少为释放空间所导致的垃圾收集。
##### 2、Java 8 中“永久代”向“元空间”的转换原因

1. 字符串等常量存在永久代中，**容易出现性能问题和内存溢出**，永久代溢出在 JSP 项目中比较常见，令人头疼。
2. **类及方法的信息等比较难确定其大小**，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。放入内存中则没有这种担忧。
3. 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。
4. HotSpot 的内部类型也是 Java 对象：它可能会在 Full GC 中被移动，同时它对应用不透明，且是非强类型的，难以跟踪调试，还需要存储元数据的元数据信息（meta-metadata）。
5. 简化 Full GC：每一个回收器有专门的元数据迭代器。
6. 它的大小是在启动时固定好的——**难以进行调优**。（与 2 类似）
7. Oracle 为融合 HotSpot JVM 与 JRockit VM（新 JVM 技术）而做出的改变，因为 JRockit 没有永久代。  
8. 使得原来受限于持久代的一些改进未来有可能实现。

##### 3、移除永久代后，PermGen space 的状况

- 这部分内存空间将全部移除。
- JVM的参数：PermSize 和 MaxPermSize 会被忽略并给出警告（如果在启用时设置了这两个参数）。

##### 4、Metaspace 的组成

- **Klass Metaspace:** Klass  Metaspace 就是用来存 **klass** 的，klass 是我们熟知的 **class 文件在 JVM 里的运行时数据结构**，不过有点要提的是类似 A.class 其实是存在 Heap 里的，是 java.lang.Class 的一个对象实例。这块内存是紧接着 Heap 的，和永久代一样，这块内存大小可通过 -XX:CompressedClassSpaceSize 参数来控制，这个参数默认是 1G，但是这块内存也可以没有，假如没有开启压缩指针就不会有这块内存，这种情况下 klass 都会存在 NoKlass  Metaspace 里，另外如果把 -Xmx（堆内存最大空间）设置大于 32G 的话，其实也是没有这块内存的，因为会这么大内存会关闭压缩指针开关。还有就是这块内存最多只会存在一块。
- **NoKlass Metaspace**: NoKlass  Metaspace 专门来存 klass 相关的其他内容，比如method、constantPool 等，这块内存是由多块内存组合起来的，所以可以认为是不连续的内存块组成的。这块内存是**必须**的，虽然叫做 NoKlass Metaspace，但是也其实可以存 klass的内容，上面已经提到了对应场景。

​        Klass Metaspace 和 NoKlass  Mestaspace 都是**所有类加载器共享**的，所以类加载器们要分配内存，但是每个类加载器都有一个 SpaceManager，来管理属于这个类加载的内存小块。若 Klass Metaspace 用完了，那就会抛出 OOM，不过一般情况下不会，因为 NoKlass  Mestaspace 是由一块块内存慢慢组合起来的，在没有达到限制条件的情况下，会不断加长这条链，让它可以持续工作。

##### 5、元空间的特点

1. 充分利用了 Java 语言规范中的好处：**类及相关的元数据的生命周期与类加载器的一致**。
2. **每个加载器有专门的存储空间**。
3. 只进行线性分配。
4. 不会单独回收某个类。
5. **省掉了 GC 扫描及压缩的时间**。
6. 元空间里的对象的位置是固定的。
7. 如果 GC 发现某个类加载器不再存活了，会把相关的空间整个回收掉。

##### 6、元空间的内存分配模型

1. 绝大多数的**类元数据**的空间都从**本地内存**中分配。

2. 用来**描述类元数据的类（klasses）**也被删除了。

3. 分元数据分配了多个虚拟内存空间。

4. 给每个类加载器分配一个内存块的列表。块的大小取决于类加载器的类型; sun /反射/代理对应的类加载器的块会小一些。

5. 归还内存块，释放内存块列表。

6. 一旦元空间的数据被清空了，虚拟内存的空间会被回收掉。

7. 减少碎片的策略。

![image](D:\Document\Typora Local File\Java\JVM\元空间内存管理.png)

> 图为元空间中的虚拟内存空间分配示意图，以及加载器的组块分配情况。CL1 申请了 BCL 中一块空闲内存，此时元空间可看作 VS1；CL2 也申请了一块内存，此时为 VS2；而后 CL2 生命周期结束，被 GC 回收，空闲的内存又分配给了 CL3，此时为 VS3。

##### 7、元空间内存管理

​        元空间的内存管理由**元空间虚拟机**来完成。先前，对于类的元数据我们需要不同的垃圾回收器进行处理，现在只需要执行元空间虚拟机的 C++ 代码即可完成。在元空间中，**类和其元数据的生命周期和其对应的类加载器是相同的**。换句话说，只要类加载器存活，其加载的类的元数据也是存活的，因而不会被回收掉。
​        准确的说，**每一个类加载器的存储区域都可以称作一个“子”元空间**，所有的“子”元空间合在一起就是我们一直说的元空间。**当一个类加载器被垃圾回收器标记为不再存活，其对应的元空间会被回收**。在元空间的回收过程中没有重定位和压缩等操作。但是**元空间内的元数据会进行扫描来确定 Java 引用**。
​        **元空间虚拟机负责元空间的分配，其采用的形式为组块分配**。组块的大小因类加载器的类型而异。在元空间虚拟机中存在一个**全局的空闲组块列表**。当一个类加载器需要组块时，它就会从这个全局的组块列表中获取并维持一个自己的组块列表。当一个类加载器不再存活，那么其持有的组块将会被释放，并返回给全局组块列表。**类加载器持有的组块又会被分成多个块，每一个块存储一个单元的元信息**。组块中的块是**线性分配**（指针碰撞分配形式）。组块分配自内存映射区域。这些全局的虚拟内存映射区域以**链表形式连接**，一旦某个虚拟内存映射区域清空，这部分内存就会返回给操作系统。 

#### 五、意义：提高了GC的性能

理解了元空间的概念，很容易发现 GC 的性能得到了提升。

1. Full GC 中，元数据指向元数据的那些指针都不用再扫描了。很多复杂的元数据扫描的代码（尤其是 CMS 里面的那些）都删除了。
2. 元空间只有少量的指针指向 Java 堆。这包括：类的元数据中指向 java/lang/Class 实例的指针；数组类的元数据中，指向 java/lang/Class 集合的指针。
3. 没有元数据压缩的开销。
4. 减少了根对象的扫描（不再扫描虚拟机里面的已加载类的字典以及其它的内部哈希表）。
5. 减少了 Full GC 的时间。
6. G1 回收器中，并发标记阶段完成后可以进行类的卸载。

#### 六、元空间的垃圾回收

​        对于一个 64 位的服务器端 JVM 来说，其默认的 –XX:MetaspaceSize 值为21MB。这就是初始的高水位线。一旦触及到这个水位线，Full GC 将会被触发并卸载没有用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会**重置**。新的高水位线的值**取决于 GC 后释放了多少元空间**。如果释放的空间少，这个高水位线则上升。如果释放空间过多，则高水位线下降。如果初始化的高水位线设置过低， 上述高水位线调整情况会发生很多次。为了避免频繁的 GC，建议将 –XX:MetaspaceSize 设置为一个相对较高的值。
​        经过多次 GC 之后，元空间虚拟机自动调节高水位线，以此来推迟下一次垃圾回收到来。上文提过的两个参数 -XX:MinMetaspaceFreeRatio和 -XX:sMaxMetaspaceFreeRatio，类似于 GC 的 FreeRatio 选项，用来设置元空间空闲比例的最大值和最小值。

#### 七、元空间存在的问题

​        元空间虚拟机采用了**组块分配的形式**，同时**区块的大小由类加载器类型决定。**类信息并不是固定大小，因此有可能分配的空闲区块和类需要的区块大小不同，这种情况下很可能导致碎片产生。元空间虚拟机目前并不支持压缩操作，所以**碎片化**是目前最大的问题。 

---

#### 导致 OutOfMemoryError 异常的常见原因有以下几种：

1. 内存中加载的数据量过于庞大，如一次从数据库取出过多数据。
2. 集合类中有对对象的引用，使用完后未清空，使得 JVM 不能回收。
3. 代码中存在死循环或循环产生过多重复的对象实体。
4. 使用的第三方软件中的 BUG。
5. 启动参数内存值设定的过小。
6. 内存中开辟了过多的线程，导致新的线程无法申请到内存空间。

#### 导致 OutOfMemoryError 错误的解决：

需要重点排查以下几点：

1. 检查代码中是否有死循环或递归调用。
2. 检查是否有大循环重复产生新对象实体。
3. 检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。
4. 检查 List、MAP 等集合对象是否有使用完后，未清除的问题。List、MAP 等集合对象会始终存有对对象的引用，使得这些对象不能被 GC 回收。
5. 增加 JVM 内存大小（非长久之计）。